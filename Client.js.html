<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Client.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ActionRow.html">ActionRow</a><ul class='methods'><li data-type='method'><a href="ActionRow.html#addComponent">addComponent</a></li><li data-type='method'><a href="ActionRow.html#toJSON">toJSON</a></li></ul></li><li><a href="Attachment.html">Attachment</a></li><li><a href="AuditLog.html">AuditLog</a></li><li><a href="Button.html">Button</a><ul class='methods'><li data-type='method'><a href="Button.html#setCustomID">setCustomID</a></li><li data-type='method'><a href="Button.html#setDisabled">setDisabled</a></li><li data-type='method'><a href="Button.html#setEmoji">setEmoji</a></li><li data-type='method'><a href="Button.html#setLabel">setLabel</a></li><li data-type='method'><a href="Button.html#setStyle">setStyle</a></li><li data-type='method'><a href="Button.html#setURL">setURL</a></li><li data-type='method'><a href="Button.html#toJSON">toJSON</a></li></ul></li><li><a href="ButtonClick.html">ButtonClick</a></li><li><a href="Channel.html">Channel</a><ul class='methods'><li data-type='method'><a href="Channel.html#send">send</a></li></ul></li><li><a href="ChannelMessageManager.html">ChannelMessageManager</a><ul class='methods'><li data-type='method'><a href="ChannelMessageManager.html#fetch">fetch</a></li><li data-type='method'><a href="ChannelMessageManager.html#fetchPinned">fetchPinned</a></li><li data-type='method'><a href="ChannelMessageManager.html#sweepMessages">sweepMessages</a></li></ul></li><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method'><a href="Client.html#addMemberRole">addMemberRole</a></li><li data-type='method'><a href="Client.html#bundleCache">bundleCache</a></li><li data-type='method'><a href="Client.html#createWebhook">createWebhook</a></li><li data-type='method'><a href="Client.html#deleteChannelMessage">deleteChannelMessage</a></li><li data-type='method'><a href="Client.html#deleteWebhook">deleteWebhook</a></li><li data-type='method'><a href="Client.html#editMessage">editMessage</a></li><li data-type='method'><a href="Client.html#fetchChannel">fetchChannel</a></li><li data-type='method'><a href="Client.html#fetchChannelMessages">fetchChannelMessages</a></li><li data-type='method'><a href="Client.html#fetchChannelWebhooks">fetchChannelWebhooks</a></li><li data-type='method'><a href="Client.html#fetchMember">fetchMember</a></li><li data-type='method'><a href="Client.html#fetchMessage">fetchMessage</a></li><li data-type='method'><a href="Client.html#fetchRole">fetchRole</a></li><li data-type='method'><a href="Client.html#fetchWebhook">fetchWebhook</a></li><li data-type='method'><a href="Client.html#followStatusChannel">followStatusChannel</a></li><li data-type='method'><a href="Client.html#getCacheCounts">getCacheCounts</a></li><li data-type='method'><a href="Client.html#getMemberCount">getMemberCount</a></li><li data-type='method'><a href="Client.html#login">login</a></li><li data-type='method'><a href="Client.html#modifyWebhook">modifyWebhook</a></li><li data-type='method'><a href="Client.html#postWebhook">postWebhook</a></li><li data-type='method'><a href="Client.html#purgeChannelMessages">purgeChannelMessages</a></li><li data-type='method'><a href="Client.html#registerCommands">registerCommands</a></li><li data-type='method'><a href="Client.html#removeMemberRole">removeMemberRole</a></li><li data-type='method'><a href="Client.html#search">search</a></li><li data-type='method'><a href="Client.html#sendMessage">sendMessage</a></li><li data-type='method'><a href="Client.html#setStatus">setStatus</a></li></ul></li><li><a href="Command.html">Command</a><ul class='methods'><li data-type='method'><a href="Command.html#addOption">addOption</a></li><li data-type='method'><a href="Command.html#setDefaultLocale">setDefaultLocale</a></li><li data-type='method'><a href="Command.html#setDefaultMemberPermissions">setDefaultMemberPermissions</a></li><li data-type='method'><a href="Command.html#setDescription">setDescription</a></li><li data-type='method'><a href="Command.html#setDmPermission">setDmPermission</a></li><li data-type='method'><a href="Command.html#setName">setName</a></li><li data-type='method'><a href="Command.html#setNsfw">setNsfw</a></li><li data-type='method'><a href="Command.html#setType">setType</a></li><li data-type='method'><a href="Command.html#toJSON">toJSON</a></li></ul></li><li><a href="CommandChoice.html">CommandChoice</a><ul class='methods'><li data-type='method'><a href="CommandChoice.html#setDefaultLocale">setDefaultLocale</a></li><li data-type='method'><a href="CommandChoice.html#setName">setName</a></li><li data-type='method'><a href="CommandChoice.html#setValue">setValue</a></li><li data-type='method'><a href="CommandChoice.html#toJSON">toJSON</a></li></ul></li><li><a href="CommandOption.html">CommandOption</a><ul class='methods'><li data-type='method'><a href="CommandOption.html#addChoice">addChoice</a></li><li data-type='method'><a href="CommandOption.html#addOption">addOption</a></li><li data-type='method'><a href="CommandOption.html#setAutocomplete">setAutocomplete</a></li><li data-type='method'><a href="CommandOption.html#setChannelTypes">setChannelTypes</a></li><li data-type='method'><a href="CommandOption.html#setDefaultLocale">setDefaultLocale</a></li><li data-type='method'><a href="CommandOption.html#setDescription">setDescription</a></li><li data-type='method'><a href="CommandOption.html#setMaxLength">setMaxLength</a></li><li data-type='method'><a href="CommandOption.html#setMaxValue">setMaxValue</a></li><li data-type='method'><a href="CommandOption.html#setMinLength">setMinLength</a></li><li data-type='method'><a href="CommandOption.html#setMinValue">setMinValue</a></li><li data-type='method'><a href="CommandOption.html#setName">setName</a></li><li data-type='method'><a href="CommandOption.html#setRequired">setRequired</a></li><li data-type='method'><a href="CommandOption.html#setType">setType</a></li><li data-type='method'><a href="CommandOption.html#toJSON">toJSON</a></li></ul></li><li><a href="Dropdown.html">Dropdown</a><ul class='methods'><li data-type='method'><a href="Dropdown.html#addChannelTypes">addChannelTypes</a></li><li data-type='method'><a href="Dropdown.html#addOption">addOption</a></li><li data-type='method'><a href="Dropdown.html#setCustomID">setCustomID</a></li><li data-type='method'><a href="Dropdown.html#setDisabled">setDisabled</a></li><li data-type='method'><a href="Dropdown.html#setMaxValue">setMaxValue</a></li><li data-type='method'><a href="Dropdown.html#setMinValue">setMinValue</a></li><li data-type='method'><a href="Dropdown.html#setPlaceholder">setPlaceholder</a></li><li data-type='method'><a href="Dropdown.html#setType">setType</a></li><li data-type='method'><a href="Dropdown.html#toJSON">toJSON</a></li></ul></li><li><a href="DropdownOption.html">DropdownOption</a><ul class='methods'><li data-type='method'><a href="DropdownOption.html#setDefault">setDefault</a></li><li data-type='method'><a href="DropdownOption.html#setDescription">setDescription</a></li><li data-type='method'><a href="DropdownOption.html#setEmoji">setEmoji</a></li><li data-type='method'><a href="DropdownOption.html#setLabel">setLabel</a></li><li data-type='method'><a href="DropdownOption.html#setValue">setValue</a></li><li data-type='method'><a href="DropdownOption.html#toJSON">toJSON</a></li></ul></li><li><a href="Embed.html">Embed</a><ul class='methods'><li data-type='method'><a href="Embed.html#addField">addField</a></li><li data-type='method'><a href="Embed.html#setAuthor">setAuthor</a></li><li data-type='method'><a href="Embed.html#setColor">setColor</a></li><li data-type='method'><a href="Embed.html#setDescription">setDescription</a></li><li data-type='method'><a href="Embed.html#setFooter">setFooter</a></li><li data-type='method'><a href="Embed.html#setImage">setImage</a></li><li data-type='method'><a href="Embed.html#setThumbnail">setThumbnail</a></li><li data-type='method'><a href="Embed.html#setTimestamp">setTimestamp</a></li><li data-type='method'><a href="Embed.html#setTitle">setTitle</a></li><li data-type='method'><a href="Embed.html#setURL">setURL</a></li><li data-type='method'><a href="Embed.html#toJSON">toJSON</a></li><li data-type='method'><a href="Embed.html#toString">toString</a></li></ul></li><li><a href="Emoji.html">Emoji</a></li><li><a href="Guild.html">Guild</a><ul class='methods'><li data-type='method'><a href="Guild.html#ban">ban</a></li><li data-type='method'><a href="Guild.html#calculateMemberCacheCount">calculateMemberCacheCount</a></li><li data-type='method'><a href="Guild.html#calculateMessageCacheCount">calculateMessageCacheCount</a></li><li data-type='method'><a href="Guild.html#fetchAuditLogs">fetchAuditLogs</a></li><li data-type='method'><a href="Guild.html#fetchBan">fetchBan</a></li><li data-type='method'><a href="Guild.html#fetchChannels">fetchChannels</a></li><li data-type='method'><a href="Guild.html#fetchInvites">fetchInvites</a></li><li data-type='method'><a href="Guild.html#kick">kick</a></li><li data-type='method'><a href="Guild.html#leave">leave</a></li><li data-type='method'><a href="Guild.html#me">me</a></li><li data-type='method'><a href="Guild.html#removeMemberRole">removeMemberRole</a></li><li data-type='method'><a href="Guild.html#unban">unban</a></li></ul></li><li><a href="GuildChannelsManager.html">GuildChannelsManager</a><ul class='methods'><li data-type='method'><a href="GuildChannelsManager.html#fetch">fetch</a></li></ul></li><li><a href="GuildEmojisManager.html">GuildEmojisManager</a><ul class='methods'><li data-type='method'><a href="GuildEmojisManager.html#fetch">fetch</a></li></ul></li><li><a href="GuildInviteManager.html">GuildInviteManager</a><ul class='methods'><li data-type='method'><a href="GuildInviteManager.html#fetch">fetch</a></li></ul></li><li><a href="GuildManager.html">GuildManager</a></li><li><a href="GuildMemberManager.html">GuildMemberManager</a><ul class='methods'><li data-type='method'><a href="GuildMemberManager.html#cleanup">cleanup</a></li><li data-type='method'><a href="GuildMemberManager.html#fetch">fetch</a></li><li data-type='method'><a href="GuildMemberManager.html#localFetch">localFetch</a></li><li data-type='method'><a href="GuildMemberManager.html#remove">remove</a></li><li data-type='method'><a href="GuildMemberManager.html#retrieve">retrieve</a></li><li data-type='method'><a href="GuildMemberManager.html#search">search</a></li><li data-type='method'><a href="GuildMemberManager.html#store">store</a></li><li data-type='method'><a href="GuildMemberManager.html#sweepMembers">sweepMembers</a></li></ul></li><li><a href="GuildRoleManager.html">GuildRoleManager</a><ul class='methods'><li data-type='method'><a href="GuildRoleManager.html#fetch">fetch</a></li></ul></li><li><a href="GuildVoiceStatesManager.html">GuildVoiceStatesManager</a></li><li><a href="Interaction.html">Interaction</a><ul class='methods'><li data-type='method'><a href="Interaction.html#acknowledge">acknowledge</a></li><li data-type='method'><a href="Interaction.html#autocompleteResponse">autocompleteResponse</a></li><li data-type='method'><a href="Interaction.html#edit">edit</a></li><li data-type='method'><a href="Interaction.html#reply">reply</a></li><li data-type='method'><a href="Interaction.html#textPrompt">textPrompt</a></li></ul></li><li><a href="Invite.html">Invite</a></li><li><a href="Member.html">Member</a><ul class='methods'><li data-type='method'><a href="Member.html#addRole">addRole</a></li><li data-type='method'><a href="Member.html#massUpdateRoles">massUpdateRoles</a></li><li data-type='method'><a href="Member.html#removeRole">removeRole</a></li><li data-type='method'><a href="Member.html#timeoutAdd">timeoutAdd</a></li><li data-type='method'><a href="Member.html#timeoutRemove">timeoutRemove</a></li></ul></li><li><a href="Message.html">Message</a><ul class='methods'><li data-type='method'><a href="Message.html#edit">edit</a></li><li data-type='method'><a href="Message.html#reply">reply</a></li><li data-type='method'><a href="Message.html#shelf">shelf</a></li></ul></li><li><a href="MessageComponents.html">MessageComponents</a><ul class='methods'><li data-type='method'><a href="MessageComponents.html#addActionRow">addActionRow</a></li><li data-type='method'><a href="MessageComponents.html#toJSON">toJSON</a></li></ul></li><li><a href="MessagePollManager.html">MessagePollManager</a><ul class='methods'><li data-type='method'><a href="MessagePollManager.html#addVote">addVote</a></li><li data-type='method'><a href="MessagePollManager.html#removeVote">removeVote</a></li></ul></li><li><a href="MessageReactionManager.html">MessageReactionManager</a><ul class='methods'><li data-type='method'><a href="MessageReactionManager.html#addReaction">addReaction</a></li><li data-type='method'><a href="MessageReactionManager.html#removeReaction">removeReaction</a></li></ul></li><li><a href="ModalResponse.html">ModalResponse</a></li><li><a href="OptionSelect.html">OptionSelect</a></li><li><a href="Reaction.html">Reaction</a></li><li><a href="Role.html">Role</a></li><li><a href="ScheduledEvent.html">ScheduledEvent</a></li><li><a href="SlashCommand.html">SlashCommand</a></li><li><a href="Sticker.html">Sticker</a></li><li><a href="TextChannel.html">TextChannel</a><ul class='methods'><li data-type='method'><a href="TextChannel.html#bulkDelete">bulkDelete</a></li><li data-type='method'><a href="TextChannel.html#send">send</a></li></ul></li><li><a href="TextInput.html">TextInput</a><ul class='methods'><li data-type='method'><a href="TextInput.html#setCustomID">setCustomID</a></li><li data-type='method'><a href="TextInput.html#setLabel">setLabel</a></li><li data-type='method'><a href="TextInput.html#setMaxLength">setMaxLength</a></li><li data-type='method'><a href="TextInput.html#setMinLength">setMinLength</a></li><li data-type='method'><a href="TextInput.html#setPlaceholder">setPlaceholder</a></li><li data-type='method'><a href="TextInput.html#setStyle">setStyle</a></li><li data-type='method'><a href="TextInput.html#setValue">setValue</a></li><li data-type='method'><a href="TextInput.html#toJSON">toJSON</a></li></ul></li><li><a href="Thread.html">Thread</a><ul class='methods'><li data-type='method'><a href="Thread.html#send">send</a></li></ul></li><li><a href="User.html">User</a></li><li><a href="UserManager.html">UserManager</a><ul class='methods'><li data-type='method'><a href="UserManager.html#fetch">fetch</a></li><li data-type='method'><a href="UserManager.html#sweepUsers">sweepUsers</a></li></ul></li><li><a href="VoiceChannel.html">VoiceChannel</a></li><li><a href="VoiceState.html">VoiceState</a></li></ul><h3>Global</h3><ul><li><a href="global.html#cacheChannel">cacheChannel</a></li><li><a href="global.html#checkPermission">checkPermission</a></li><li><a href="global.html#decryptMessage">decryptMessage</a></li><li><a href="global.html#decryptText">decryptText</a></li><li><a href="global.html#deepCompare">deepCompare</a></li><li><a href="global.html#encryptMessage">encryptMessage</a></li><li><a href="global.html#encryptText">encryptText</a></li><li><a href="global.html#getAvatarUrl">getAvatarUrl</a></li><li><a href="global.html#getMessage">getMessage</a></li><li><a href="global.html#getTimestamp">getTimestamp</a></li><li><a href="global.html#resolveEmoji">resolveEmoji</a></li><li><a href="global.html#verifyMessageLink">verifyMessageLink</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">Client.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* i think one process should be able to handle multiple shards (ideally max_concurrency's worth) */
const {
  BASE_URL,
  VERSION,
  NAME,
  CHANNEL_TYPES,
  DEFAULT_MESSAGE_EXPIRY_SECONDS,
  DEFAULT_USER_EXPIRY_SECONDS,
  DEFAULT_CACHE_CHECK_PERIOD,
  DEFAULT_INCREASE_CACHE_BY,
} = require("./constants");

const EventsEmitter = require("events");
const mysql = require("mysql2/promise");
const AWS = require("aws-sdk");

const BetterRequestHandler = require("./rest/betterRequestHandler");
const WS = require("./gateway/index");

const UserManager = require("./managers/UserManager");
const GuildManager = require("./managers/GuildManager");
const Message = require("./structures/Message");
const Guild = require("./structures/Guild");
const User = require("./structures/User");
const generateWebsocketURL = require("./util/gluon/generateWebsocketURL");
const Member = require("./structures/Member");
const cacheChannel = require("./util/gluon/cacheChannel");
const Role = require("./structures/Role");

/**
 * A client user, which is able to handle multiple shards.
 */
class Client extends EventsEmitter {
  /**
   * Creates the client and sets the default options.
   * @constructor
   * @param {Object?} options The options to pass to the client.
   */
  constructor({
    cacheMessages = false,
    cacheUsers = false,
    cacheMembers = false,
    cacheChannels = false,
    cacheGuilds = false,
    cacheVoiceStates = false,
    cacheRoles = false,
    cacheScheduledEvents = false,
    cacheEmojis = false,
    cacheInvites = false,
    cacheAllMembers = false,
    defaultMessageExpiry = DEFAULT_MESSAGE_EXPIRY_SECONDS,
    defaultUserExpiry = DEFAULT_USER_EXPIRY_SECONDS,
    increaseCacheBy = DEFAULT_INCREASE_CACHE_BY,
    intents,
    totalShards,
    shardIds,
    sessionData,
    initCache,
    softRestartFunction,
    mySqlPassword,
    s3Url,
    s3MessageBucket,
    s3AccessKeyId,
    s3SecretAccessKey,
  } = {}) {
    super();

    this.shards = [];

    /**
     * The Discord API base URL.
     * @type {String}
     */
    this.baseURL = BASE_URL;

    /**
     * The Discord API version to use.
     * @type {String}
     */
    this.version = VERSION;

    /**
     * The name of this lib.
     * @type {String}
     */
    this.name = NAME;

    /**
     * The intents to use when connecting with this client.
     * @type {Number?}
     */
    this.intents = intents;

    /**
     * Whether this client should cache messages.
     * @type {Boolean}
     */
    this.cacheMessages = cacheMessages;

    /**
     * Whether this client should cache users.
     * @type {Boolean}
     */
    this.cacheUsers = cacheUsers;

    /**
     * Whether this client should cache members.
     * @type {Boolean}
     */
    this.cacheMembers = cacheMembers;

    /**
     * Whether this client should cache channels.
     * @type {Boolean}
     */
    this.cacheChannels = cacheChannels;

    /**
     * Whether this client should cache guilds.
     * @type {Boolean}
     */
    this.cacheGuilds = cacheGuilds;

    /**
     * Whether this client should cache voice states.
     * @type {Boolean}
     */
    this.cacheVoiceStates = cacheVoiceStates;

    /**
     * Whether this client should cache roles.
     * @type {Boolean}
     */
    this.cacheRoles = cacheRoles;

    /**
     * Whether this client should cache scheduled events.
     * @type {Boolean}
     */
    this.cacheScheduledEvents = cacheScheduledEvents;

    /**
     * Whether this client should cache emojis.
     * @type {Boolean}
     */
    this.cacheEmojis = cacheEmojis;

    /**
     * Whether this client should cache invites.
     * @type {Boolean}
     */
    this.cacheInvites = cacheInvites;

    /**
     * Whether this client should fetch and subsequently cache all members.
     * Overrides cacheMembers
     * @type {Boolean}
     */
    this.cacheAllMembers = cacheAllMembers;

    /**
     * The base message expiry time, in seconds.
     * @type {Number}
     */
    this.defaultMessageExpiry = defaultMessageExpiry;

    /**
     * The base user expiry time, in seconds.
     * @type {Number}
     */
    this.defaultUserExpiry = defaultUserExpiry;

    /**
     * An array of the shard ids that this client is handling.
     * @type {Number[]?}
     */
    this.shardIds = shardIds;

    /**
     * The total shards the bot is using.
     * @type {Number?}
     */
    this.totalShards = totalShards;

    this._sessionData = sessionData;

    /**
     * The client user.
     * @type {User?}
     */
    this.user = null;

    if (initCache?.clientUser) this.user = new User(this, initCache.clientUser);

    /**
     * The user manager for this client.
     * @type {UserManager}
     */
    this.users = new UserManager(this);

    /**
     * The guild manager for this client.
     * @type {GuildManager}
     */
    this.guilds = new GuildManager(this);

    if (initCache?.guilds)
      for (let i = 0; i &lt; initCache.guilds.length; i++)
        new Guild(this, initCache.guilds[i]);

    this.increasedCache = new Map();
    this.increasedCacheMultipliers = new Map();
    this.increaseCacheBy = increaseCacheBy;

    this.softRestartFunction = softRestartFunction;

    const connection = mysql.createPool({
      host: "localhost",
      user: "root",
      password: mySqlPassword,
      database: "dataStorage",
      waitForConnections: true,
      connectionLimit: 10,
      maxIdle: 10, // max idle connections, the default value is the same as `connectionLimit`
      idleTimeout: 60000, // idle connections timeout, in milliseconds, the default value 60000
      queueLimit: 0,
      enableKeepAlive: true,
      keepAliveInitialDelay: 0,
      namedPlaceholders: true,
      bigNumberStrings: true,
      supportBigNumbers: true,
    });

    this.dataStorage = connection;

    const s3Messages = new AWS.S3({
      endpoint: `${s3Url}${s3MessageBucket}`,
      accessKeyId: s3AccessKeyId,
      secretAccessKey: s3SecretAccessKey,
      s3BucketEndpoint: true,
    });

    this.s3MessageBucket = s3MessageBucket;

    this.s3Messages = s3Messages;

    this.s3Messages.putBucketLifecycleConfiguration(
      {
        Bucket: s3MessageBucket,
        LifecycleConfiguration: {
          Rules: [
            {
              Expiration: {
                Days: 30,
              },
              Status: "Enabled",
              Filter: {
                Prefix: "",
              },
              ID: "DeleteOldFiles",
            },
          ],
        },
      },
      (err, data) => {
        if (err) console.log(err);
      },
    );
  }

  /**
   * Counts how many items are in each cache.
   * @returns {Object}
   */
  getCacheCounts() {
    let totalMessages = 0;
    let totalMembers = 0;
    let totalChannels = 0;
    let totalRoles = 0;

    this.guilds.cache.forEach((guild) => {
      guild.channels.cache.forEach((channel) => {
        switch (channel.type) {
          case CHANNEL_TYPES.GUILD_NEWS_THREAD:
          case CHANNEL_TYPES.GUILD_PUBLIC_THREAD:
          case CHANNEL_TYPES.GUILD_PRIVATE_THREAD:
          case CHANNEL_TYPES.GUILD_TEXT:
          case CHANNEL_TYPES.GUILD_NEWS:
          case CHANNEL_TYPES.GUILD_FORUM: {
            totalMessages += channel.messages.cache.size;
            break;
          }
          default:
            break;
        }

        totalChannels++;
      });

      totalMembers += guild.members.cache.size;

      totalRoles += guild.roles.cache.size;
    });

    return {
      users: this.users.cache.size,
      guilds: this.guilds.cache.size,
      messages: totalMessages,
      members: totalMembers,
      channels: totalChannels,
      roles: totalRoles,
    };
  }

  /**
   * Counts how many members are in all of Quark's servers.
   * @returns {Number}
   */
  getMemberCount() {
    let memberCount = 0;

    this.guilds.cache.forEach((guild) => {
      memberCount += guild.member_count;
    });

    return memberCount;
  }

  /**
   * Bundles all guilds.
   * @returns {Array&lt;Object>}
   */
  bundleCache() {
    return this.guilds;
  }

  /**
   * Fetches a message from a specific channel.
   * @param {BigInt} guild_id The ID of the guild that the message belongs to.
   * @param {BigInt} channel_id The ID of the channel that the message belongs to.
   * @param {BigInt} message_id The ID of the message to return.
   * @returns {Promise&lt;Message>}
   */
  async fetchMessage(guild_id, channel_id, message_id) {
    const data = await this.request.makeRequest("getChannelMessage", [
      channel_id,
      message_id,
    ]);

    return new Message(this, data, channel_id.toString(), guild_id.toString());
  }

  /**
   * Posts a webhook with the provided webhook id and token.
   * @param {Object} referenceData An object with the webhook id and token.
   * @param {String?} content The message to send with the webhook.
   * @param {Object?} options Embeds, components and files to attach to the webhook.
   */
  async postWebhook(
    { id, token },
    content,
    { embeds, components, files } = {},
  ) {
    const body = {};

    if (content) body.content = content;

    if (embeds) body.embeds = embeds;
    if (components) body.components;
    if (files) body.files = files;

    await this.request.makeRequest("postExecuteWebhook", [id, token], body);
  }

  /**
   * Posts a message to the specified channel.
   * @param {BigInt} channel_id The id of the channel to send the message to.
   * @param {BigInt} guild_id The id of the guild which the channel belongs to.
   * @param {String?} content The message content.
   * @param {Object?} options Embeds, components and files to attach to the message.
   * @returns {Promise&lt;Message>}
   */
  async sendMessage(
    channel_id,
    guild_id,
    content,
    { embed, embeds, components, files, suppressMentions = false } = {},
  ) {
    const body = {};

    if (content) body.content = content;

    if (embed) body.embeds = [embed];
    else if (embeds &amp;&amp; embeds.length != 0)
      body.embeds = embeds;
    if (components) body.components = components;
    if (files) body.files = files;
    if (suppressMentions == true) {
      body.allowed_mentions = {};
      body.allowed_mentions.parse = [];
    }

    const data = await this.request.makeRequest(
      "postCreateMessage",
      [channel_id],
      body,
    );

    return new Message(
      this,
      data,
      channel_id.toString(),
      guild_id.toString(),
      false,
    );
  }

  /**
   * Edits a specified message.
   * @param {BigInt} channel_id The id of the channel that the message belongs to.
   * @param {BigInt} guild_id The id of the guild that the channel belongs to.
   * @param {BigInt} message_id The id of the message to edit.
   * @param {String?} content The message content.
   * @param {Object?} options Embeds, components and files to attach to the message.
   * @returns {Promise&lt;Message>}
   */
  async editMessage(
    channel_id,
    guild_id,
    message_id,
    content,
    { embed, components } = {},
  ) {
    const body = {};

    if (content) body.content = content;
    if (embed) body.embeds = [embed];
    if (components) body.components = components;

    if (this.referenced_message)
      body.message_reference = {
        message_id: message_id.toString(),
        channel_id: channel_id.toString(),
        guild_id: guild_id.toString(),
      };

    const data = await this.request.makeRequest(
      "patchEditMessage",
      [channel_id, message_id],
      body,
    );

    return new Message(this, data, channel_id, guild_id);
  }

  /**
   * Adds a specified channel as a follower to Quark's status channel.
   * @param {BigInt} channel_id The id of the channel to add as a follower.
   */
  async followStatusChannel(channel_id) {
    const body = {};

    body.webhook_channel_id = channel_id;

    await this.request.makeRequest(
      "postFollowNewsChannel",
      ["822906135048487023"],
      body,
    );
  }

  /**
   * Fetches the webhooks for a specified channel.
   * @param {BigInt} channel_id The id of the channel to fetch the webhooks from.
   * @returns {Promise&lt;Array&lt;Object>>}
   */
  fetchChannelWebhooks(channel_id) {
    return this.request.makeRequest("getChannelWebhooks", [
      channel_id,
    ]);;
  }

  /**
   * Deletes a webhook.
   * @param {BigInt} webhook_id The id of the webhook to delete.
   */
  async deleteWebhook(webhook_id) {
    await this.request.makeRequest("deleteWebhook", [webhook_id]);
  }

  /**
   * Fetches a member, checking the cache first.
   * @param {String | BigInt} guild_id The id of the guild the member belongs to.
   * @param {String | BigInt} user_id The id of the member to fetch.
   * @returns {Promise&lt;Member>}
   */
  async fetchMember(guild_id, user_id) {
    const guild = this.guilds.cache.get(guild_id.toString());

    const cached = await guild.members.localFetch(user_id.toString());

    if (cached) return cached;

    const data = await this.request.makeRequest("getGuildMember", [
      guild_id,
      user_id,
    ]);

    return new Member(
      this,
      data,
      user_id.toString(),
      guild_id.toString(),
      data.user,
    );
  }

  /**
   * Fetches a channel, checking the cache first.
   * @param {String | BigInt} guild_id The id of the guild the channel belongs to.
   * @param {String | BigInt} channel_id The id of the channel to fetch.
   * @returns {Promise&lt;TextChannel | VoiceChannel>}
   */
  async fetchChannel(guild_id, channel_id) {
    const guild = this.guilds.cache.get(guild_id.toString());

    const cached = guild.channels.cache.get(channel_id.toString());

    if (cached) return cached;

    const data = await this.request.makeRequest("getChannel", [channel_id]);

    return cacheChannel(this, data, guild_id.toString());
  }

  /**
   * Fetches a role, checking the cache first.
   * @param {String | BigInt} guild_id The id of the guild the role belongs to.
   * @param {String | BigInt | null} user_id The id of the role to fetch, or null to return all roles.
   * @returns {Promise&lt;Role | Array&lt;Role>>}
   */
  async fetchRole(guild_id, role_id) {
    const guild = this.guilds.cache.get(guild_id.toString());

    const cached = role_id
      ? guild.roles.cache.get(role_id.toString())
      : Array.from(guild.roles.cache, ([key, value]) => value);

    if (cached) return cached;

    const data = await this.request.makeRequest("getRoles", [guild_id]);

    if (!role_id) return data.map((role) => new Role(this, role, guild_id));

    let matchedRole;
    for (let i = 0; i &lt; data.length; i++) {
      const role = new Role(this, data[i], guild_id);
      if (role.id == role_id) matchedRole = role;
    }

    return matchedRole;
  }

  /**
   * Bulk deletes channel messages.
   * @param {BigInt} channel_id The id of the channel to purge messages in.
   * @param {Array&lt;String>} messages An array of message ids to delete.
   * @param {Object} options
   */
  async purgeChannelMessages(channel_id, messages, { reason }) {
    const body = {};

    body.messages = messages;

    if (reason) body["X-Audit-Log-Reason"] = reason;

    await this.request.makeRequest(
      "postBulkDeleteMessages",
      [channel_id],
      body,
    );
  }

  /**
   * Deletes one message.
   * @param {BigInt} channel_id The id of the channel that the message belongs to.
   * @param {BigInt} message_id The id of the message to delete.
   * @param {Object} options
   */
  async deleteChannelMessage(channel_id, message_id, { reason }) {
    const body = {};

    if (reason) body["X-Audit-Log-Reason"] = reason;

    await this.request.makeRequest(
      "deleteChannelMessage",
      [channel_id, message_id],
      body,
    );
  }

  /**
   * Fetches messages from a specified channel.
   * @param {BigInt} guild_id The id of the guild that the channel belongs to.
   * @param {BigInt} channel_id The id of the channel to fetch messages from.
   * @param {Object} options The filter options to determine which messages should be returned.
   * @returns {Promise&lt;Array&lt;Message>>}
   */
  async fetchChannelMessages(
    guild_id,
    channel_id,
    { around, before, after, limit },
  ) {
    const body = {};

    if (around) body.around = around;

    if (before) body.before = before;

    if (after) body.after = after;

    if (limit) body.limit = limit;

    const data = await this.request.makeRequest(
      "getChannelMessages",
      [channel_id],
      body,
    );

    const messages = [];
    for (let i = 0; i &lt; data.length; i++)
      messages.push(new Message(this, data[i], data[i].channel_id, guild_id));

    return messages;
  }

  /**
   * Creates a webhook in the given channel with the name "Quark"
   * @param {BigInt} channel_id The id of the channel to create the webhook in.
   * @returns {Promise&lt;Object>}
   */
  async createWebhook(channel_id) {
    const body = {};

    body.name = "Quark";

    const data = await this.request.makeRequest(
      "postCreateWebhook",
      [channel_id],
      body,
    );

    return data;
  }

  /**
   * Modified a webhook with the given webhook id.
   * @param {BigInt} webhook_id The id of the webhook to modify.
   * @param {Object} options The options to modify the webhook with.
   * @returns {Promise&lt;Object>}
   */
  async modifyWebhook(webhook_id, { channel_id }) {
    const body = {};

    body.channel_id = channel_id.toString();

    const data = await this.request.makeRequest(
      "patchModifyWebhook",
      [webhook_id],
      body,
    );

    return data;
  }

  /**
   * Fetches a webhook by the webhook's id.
   * @param {BigInt | String} webhook_id The id of the webhook to fetch.
   * @returns {Promise&lt;Object>}
   */
  async fetchWebhook(webhook_id) {
    const data = await this.request.makeRequest("getWebhook", [webhook_id]);

    return data;
  }

  /**
   * Registers commands, overwriting all previous ones.
   * @param {Array&lt;Command>} commands Array of commands to register.
   * @returns {Array&lt;Object>}
   * @see {@link https://discord.com/developers/docs/interactions/application-commands#registering-a-command}
   * @see {@link https://discord.com/developers/docs/interactions/application-commands#bulk-overwrite-global-application-commands}
   */
  async registerCommands(commands) {
    const body = [];

    for (let i = 0; i &lt; commands.length; i++) body.push(commands[i]);

    const data = await this.request.makeRequest(
      "bulkOverwriteGlobalApplicationCommands",
      [this.user.id],
      body,
    );

    return data;
  }

  /**
   * Adds a role to a member.
   * @param {String | BigInt} guildId The guild id the member belongs to.
   * @param {String | BigInt} userId The id of the member who the action is occuring on.
   * @param {String | BigInt} roleId The id of the role to add.
   */
  async addMemberRole(guildId, userId, roleId) {
    await this.request.makeRequest("putAddGuildMemberRole", [
      guildId,
      userId,
      roleId,
    ]);
  }

  /**
   * Removes a role from a member.
   * @param {String | BigInt} guildId The guild id the member belongs to.
   * @param {String | BigInt} userId The id of the member who the action is occuring on.
   * @param {String | BigInt} roleId The id of the role to remove.
   */
  async removeMemberRole(guildId, userId, roleId) {
    await this.request.makeRequest("deleteRemoveMemberRole", [
      guildId,
      userId,
      roleId,
    ]);
  }

  /**
   * Searches for members via a search query.
   * @param {String | BigInt} guildId The id of the guild to search.
   * @param {String} query The search query.
   * @returns {Promise&lt;Array&lt;Member>?>} The members which match the search query.
   */
  async search(guildId, query) {
    const body = {};

    body.query = query;

    body.limit = 1000;

    const data = await this.request.makeRequest(
      "getSearchGuildMembers",
      [guildId],
      body,
    );
    if (data.length != 0) {
      const members = [];

      for (let i = 0; i &lt; data.length; i++)
        members.push(
          new Member(
            this,
            data[i],
            data[i].user.id,
            guildId.toString(),
            data[i].user,
          ),
        );

      return members;
    } else return null;
  }

  /**
   * Sets the bot's status across all shards.
   * @param {Object} status Status options.
   */
  setStatus({ name, type, status, afk, since } = {}) {
    for (let i = 0; i &lt; this.shards.length; i++)
      this.shards[i].updatePresence(name, type, status, afk, since);
  }

  /**
   * Initiates the login sequence
   * @param {String} token The authorization token
   */
  login(token) {
    /* sets the token and starts logging the bot in to the gateway, shard by shard */
    this.token = token;

    this.request = new BetterRequestHandler(
      this,
      this.baseURL,
      this.name,
      this.version,
      this.token,
    );

    this.request
      .makeRequest("getGatewayBot")
      .then((gatewayInfo) => {
        let remainingSessionStarts = gatewayInfo.session_start_limit.remaining;

        if (!this.shardIds || this.shardIds.length == 0)
          this.shardIds = [...Array(gatewayInfo.shards).keys()];

        if (!this.totalShards) this.totalShards = gatewayInfo.shards;

        for (
          let i = 0;
          i &lt; this.shardIds.length &amp;&amp; remainingSessionStarts != 0;
          i++, remainingSessionStarts--
        )
          setTimeout(() => {
            for (
              let n = 0;
              n &lt; gatewayInfo.session_start_limit.max_concurrency;
              n++
            )
              this.shards.push(
                new WS(
                  this,
                  generateWebsocketURL(
                    this._sessionData
                      ? this._sessionData[i].resumeGatewayUrl
                      : gatewayInfo.url,
                  ),
                  [this.shardIds[i], this.totalShards],
                  this.intents,
                  this._sessionData
                    ? this._sessionData[i].sessionId
                    : undefined,
                  this._sessionData ? this._sessionData[i].sequence : undefined,
                  this._sessionData
                    ? this._sessionData[i].resumeGatewayUrl
                    : undefined,
                  this.softRestartFunction,
                ),
              );
          }, 6000 * i);

        if (
          this.cacheMessages == true ||
          (this.cacheMembers == true &amp;&amp; this.cacheAllMembers != true) ||
          this.cacheUsers == true
        )
          setInterval(async () => {
            // store all members

            // if (this.cacheMembers == true) {
            //     let fullMembersList = [];
            //     this.guilds.cache.forEach(guild => {

            //         Array.from(guild.members.cache, ([key, value]) => fullMembersList.push(value));

            //     });

            //     const valuesTemplate = fullMembersList.map(() => `(?, ?, ?, ?, ?, ?, ?)`).join(',');
            //     let values = [];
            //     let memberRolesValues = [];

            //     for (let i = 0; i &lt; fullMembersList.length; i++) {
            //         // (:id, :guild, :nick, :joined_at, :avatar, :communication_disabled_until, :attributes)
            //         values.push(fullMembersList[i].id);
            //         values.push(fullMembersList[i].guild.id);
            //         values.push(fullMembersList[i].nick);
            //         values.push(fullMembersList[i].joined_at);
            //         values.push(fullMembersList[i].formattedAvatarHash);
            //         values.push(fullMembersList[i].communication_disabled_until);
            //         values.push(fullMembersList[i]._attributes);
            //         if (Array.isArray(fullMembersList[i]._roles) &amp;&amp; fullMembersList[i]._roles.length > 0) {
            //             for (let n = 0; n &lt; fullMembersList[i]._roles.length; n++)
            //                 memberRolesValues.push(fullMembersList[i].id, fullMembersList[i]._roles[n], fullMembersList[i].guild.id);
            //         }
            //     }

            //     await this.dataStorage.query(`INSERT INTO Members (id, guild, nick, joined_at, avatar, communication_disabled_until, attributes) VALUES ${valuesTemplate} ON DUPLICATE KEY UPDATE nick = VALUES(nick), avatar = VALUES(avatar), communication_disabled_until = VALUES(communication_disabled_until), attributes = VALUES(attributes);`, values)
            //         .then(() => this.emit("debug", `ADDED ${fullMembersList.length} MEMBERS TO STORAGE`));

            //     await this.dataStorage.query(`INSERT INTO MemberRoles (memberid, roleid, guild) VALUES ${Array(memberRolesValues.length / 3).fill("(?, ?, ?)").join(',')} ON DUPLICATE KEY UPDATE memberid = VALUES(memberid), roleid = VALUES(roleid), guild = VALUES(guild);`, memberRolesValues)
            //         .then(() => this.emit("debug", `ADDED ${memberRolesValues.length} TO MEMBER ROLES STORAGE`));

            // }

            // if (this.cacheUsers == true) {
            //     let fullUsersList = [];

            //     Array.from(this.users.cache, ([key, value]) => fullUsersList.push(value));

            //     const valuesTemplate = fullUsersList.map(() => `(?, ?, ?, ?, ?, ?)`).join(',');
            //     const values = [];

            //     for (let i = 0; i &lt; fullUsersList.length; i++) {
            //         // (:id, :avatar, :username, :global_name, :discriminator, :attributes)
            //         values.push(fullUsersList[i].id);
            //         values.push(fullUsersList[i].formattedAvatarHash);
            //         values.push(fullUsersList[i].username);
            //         values.push(fullUsersList[i].global_name);
            //         values.push(fullUsersList[i].discriminator);
            //         values.push(fullUsersList[i]._attributes);
            //     }

            //     await this.dataStorage.query(`INSERT INTO Users (id, avatar, username, global_name, discriminator, attributes) VALUES ${valuesTemplate} ON DUPLICATE KEY UPDATE avatar = VALUES(avatar), username = VALUES(username), global_name = VALUES(global_name), discriminator = VALUES(discriminator), attributes = VALUES(attributes);`, values)
            //         .then(() => this.emit("debug", `ADDED ${fullUsersList.length} USERS TO STORAGE`));

            // }

            const currentTime = Math.floor(new Date().getTime() / 1000);

            if (
              this.cacheMessages == true ||
              (this.cacheMembers == true &amp;&amp; this.cacheAllMembers != true)
            )
              this.guilds.cache.forEach((guild) => {
                if (this.cacheMessages == true) {
                  this.emit(
                    "debug",
                    `Sweeping messages for GUILD ${guild.id}...`,
                  );

                  let cacheCount = guild.calculateMessageCacheCount() * 2;
                  // if (this.increasedCache.get(guild.id.toString()))
                  //     cacheCount = 0;

                  this.emit(
                    "debug",
                    `Calculated limit of ${cacheCount} per channel for GUILD ${guild.id}...`,
                  );

                  guild.channels.cache.forEach(async (channel) => {
                    this.emit(
                      "debug",
                      `Sweeping messages for CHANNEL ${channel.id}...`,
                    );

                    const nowCached = channel.messages.sweepMessages(
                      cacheCount,
                      currentTime,
                    );

                    this.emit(
                      "debug",
                      `New cache size of ${nowCached || 0} for CHANNEL ${
                        guild.id
                      }...`,
                    );
                  });
                }

                if (
                  (this.cacheMembers == true &amp;&amp; this.cacheAllMembers != true) ||
                  this.cacheMessages == true
                ) {
                  this.emit(
                    "debug",
                    `Sweeping members for GUILD ${guild.id}...`,
                  );

                  let cacheCount = guild.calculateMemberCacheCount();
                  // if (this.increasedCache.get(guild.id.toString()))
                  //     cacheCount *= this.increaseCacheBy;

                  this.emit(
                    "debug",
                    `Calculated limit of ${cacheCount} for GUILD ${guild.id}...`,
                  );

                  this.emit(
                    "debug",
                    `Sweeping members for GUILD ${guild.id}...`,
                  );

                  const nowCached = guild.members.sweepMembers(cacheCount);

                  this.emit(
                    "debug",
                    `New cache size of ${nowCached || 0} for GUILD ${
                      guild.id
                    }...`,
                  );
                }
              });

            if (this.cacheUsers == true || this.cacheMessages == true) {
              this.emit("debug", "Sweeping users...");

              const nowCached = this.users.sweepUsers(currentTime);

              this.emit("debug", `New user cache size is ${nowCached || 0}...`);
            }
          }, DEFAULT_CACHE_CHECK_PERIOD); // every 1 hour 1000 * 60 * 60
      })
      .catch((error) => {
        this.emit(
          "debug",
          "Get gateway bot request failed, terminating process",
        );

        console.log(error);

        process.exit(0);
      });
  }
}

module.exports = Client;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Jul 17 2024 15:19:45 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
