<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      rest/requestHandler.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/heading.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="1048234" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=5471314><div class="accordion-heading child"><a href="Client.html">Client</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Client.html#deleteWebhook">deleteWebhook</a></li><li data-type='method'><a href="Client.html#editMessage">editMessage</a></li><li data-type='method'><a href="Client.html#error">error</a></li><li data-type='method'><a href="Client.html#fetchChannelMessages">fetchChannelMessages</a></li><li data-type='method'><a href="Client.html#fetchChannelWebhooks">fetchChannelWebhooks</a></li><li data-type='method'><a href="Client.html#followStatusChannel">followStatusChannel</a></li><li data-type='method'><a href="Client.html#login">login</a></li><li data-type='method'><a href="Client.html#postWebhook">postWebhook</a></li><li data-type='method'><a href="Client.html#purgeChannelMessages">purgeChannelMessages</a></li><li data-type='method'><a href="Client.html#sendMessage">sendMessage</a></li><li data-type='method'><a href="Client.html#setStatus">setStatus</a></li></ul></li><li class="accordion collapsed child" id=2864566><div class="accordion-heading child"><a href="Message.html">Message</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Message.html#edit">edit</a></li><li data-type='method'><a href="Message.html#reply">reply</a></li></ul></li></ul> </div></div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        rest/requestHandler.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const fetch = require("node-fetch");
const FormData = require("form-data");
const endpoints = require("./endpoints");
const { createReadStream } = require("fs");

class RequestHandler {

    constructor(baseURL, name, version, token) {

        this.baseURL = baseURL;
        this.version = version;
        this.requestURL = `${this.baseURL}/v${this.version}`;
        this.requestQueue = [];
        this.bucket = {};

        this.token = token;
        this.authorization = `Bot ${this.token}`;
        this.name = name;

        this.endpoints = endpoints;

        this.inProgressRequests = [];
        this.inProgressBuckets = [];

        this.delayInitiated = false;

    }

    /**
     * Sets the bucket information, should be called after every request to keep data up-to-date
     * @param {string} requestName Name of the request, defined in ./endpoints.js
     * @param {string} ratelimitBucket Ratelimit bucket id
     * @param {integer} ratelimitRemaining Number of requests remaining until 429s will be hit
     * @param {integer} ratelimitReset Unix timestamp of when the ratelimitRemaining will reset
     */
    handleBucket(requestName, ratelimitBucket, ratelimitRemaining, ratelimitReset) {

        this.bucket[ratelimitBucket] = {
            remaining: ratelimitRemaining,
            reset: parseFloat(ratelimitReset)
        };

        /* sets the bucket id of the endpoint that was just requested */
        /* bucket ids can be the same per endpoint */
        /* they can also change without notice */
        /* best to keep updating it to ensure it always stays up-to-date for each endpoint */
        /* crucial for if the bot is running for extended periods of time without restarts too */
        this.endpoints[requestName].bucket = ratelimitBucket;

    }

    /**
    * Attempts the next queued request and removes the current one from the "in-progress" list
    */
    nextRequest() {

        /* if there are remaining requests in the request queue, they can be attempted */
        if (this.requestQueue.length != 0) {

            const nextRequest = this.requestQueue.shift();
            this.makeRequest(nextRequest.request, nextRequest.params, nextRequest.body, nextRequest.resolve, nextRequest.reject);

        }

    }

    /**
     * Makes the request if possible, otherwise will queue the request for later
     * @param {string} request Name of the request, defined in ./endpoints.js
     * @param {string[]} params Array of params to include in the URL, in the order they should be in
     * @param {object} body The request body
     * @param {function} resolve The function to resolve the promise, so the data can be returned to the correct place
     * @param {function} reject The function to reject the promise, to make clear the request has failed
     */
    async makeRequest(request, params, body, resolve, reject) {
        return new Promise(async (_resolve, _reject) => {

            /* if there are none of the same bucket (or request if bucket is null) in progress, and also that the bucket has requests remaining */
            if (
                /* checks if there is actually a set bucket id for this request yet */
                /* there won't be if this is the first request */
                (this.endpoints[request].bucket != null ?
                    !this.inProgressBuckets.includes(this.endpoints[request].bucket) :
                    /* if there isn't, simply check the requests that are in progress */
                    /* this should not be completely relied on as I believe bucket ids *can* also vary on the same endpoint */
                    /* but with different params */
                    /* either way, the bucket id is the only truly reliable way of monitoring ratelimits */
                    !this.inProgressRequests.includes(request)
                )
                &amp;&amp;
                /* again, check if there is a valid bucket id attached to this request */
                (this.endpoints[request].bucket != null ?
                    /* now check if there are greater than 0 remaining requests available for this bucket */
                    (this.bucket[this.endpoints[request].bucket]?.remaining != 0 ?
                        /* if there are, this should return true so the request can be made */
                        (true) :
                        /* otherwise check if the bucket reset time has reset */
                        /* which would reset our remaining requests back to the original value */
                        /* so we can proceed with the request if this is the case */
                        ((new Date().getTime() / 1000) > this.bucket[this.endpoints[request].bucket]?.reset)) :
                    /* yeah im so lost but i am 99% sure this works */
                    (true)
                )
            ) {
                /* add the current request to the "in-progress" list*/
                /* only one request of each bucket id should ever take place at a time */
                this.inProgressRequests.push(request);
                if (this.endpoints[request].bucket)
                    this.inProgressBuckets.push(this.endpoints[request].bucket);
                /* fetch the request data from ./endpoints.js */
                /* important it is fetched from there, as bucket ids are also stored there with that data */
                const actualRequest = this.endpoints[request];

                const serialize = (obj) => {
                    let str = [];
                    for (let p in obj)
                        if (obj.hasOwnProperty(p))
                            str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
                    return str.join("&amp;");
                };

                let headers = {
                    "Authorization": this.authorization,
                    "User-Agent": this.name,
                    "Accept": "application/json"
                };

                let form;
                if (body &amp;&amp; body.files) {
                    form = new FormData();
                    for (let i = 0; i &lt; body.files.length; i++)
                        form.append(body.files[i].name, createReadStream(body.files[i].attachment), body.files[i].name);
                    delete body.files;
                    form.append("payload_json", JSON.stringify(body));
                    Object.assign(headers, form.getHeaders());
                } else if (actualRequest.method != "GET" &amp;&amp; actualRequest.method != "DELETE")
                    headers["Content-Type"] = "application/json";

                if (actualRequest.useHeaders)
                    for (const [key, value] of Object.entries(body))
                        headers[key] = value;

                /* actually make the request */
                const res = await fetch(`${this.requestURL}${actualRequest.path(params)}${body &amp;&amp; (actualRequest.method == "GET" || actualRequest.method == "DELETE") &amp;&amp; actualRequest.useHeaders != true ? "?" + serialize(body) : ""}`, {
                    method: actualRequest.method,
                    headers: headers,
                    body: form ? form : (body &amp;&amp; (actualRequest.method != "GET" &amp;&amp; actualRequest.method != "DELETE") &amp;&amp; actualRequest.useHeaders != true ? JSON.stringify(body) : undefined),
                    compress: true
                });

                let json;
                
                try {

                    json = await res.json();

                } catch (error) {

                    json = null;

                }

                /* update the bucket data */
                this.handleBucket(request, res.headers.get("x-ratelimit-bucket"), res.headers.get("x-ratelimit-remaining"), res.headers.get("x-ratelimit-reset"));

                /* stops blocking new requests made */
                /* ideally, the next request that should be made should be one in the queue */
                /* however, at just the wrong timing, a newer request can "slip in" */
                /* not the largest issue in the world, but it makes sense to follow the queue */
                /* so removing the current request from the "in-progress" list should be done as late as possible */
                this.inProgressRequests.splice(this.inProgressRequests.indexOf(request), 1);
                if (this.endpoints[request].bucket)
                    this.inProgressBuckets.splice(this.inProgressBuckets.indexOf(this.endpoints[request].bucket), 1);

                this.nextRequest();

                if (res.status >= 200 &amp;&amp; res.status &lt; 300)
                    return resolve ? resolve(json) : _resolve(json);
                else
                    return reject ? reject(json) : _reject(json);

            } else {
                /* i am wondering if it would make more sense to have a request queue per bucket id? */
                this.requestQueue.push({
                    request: request,
                    params: params,
                    body: body,
                    resolve: resolve ? resolve : _resolve,
                    reject: reject ? reject : _reject
                });

                if (this.delayInitiated == false) {

                    this.delayInitiated = true;

                    setTimeout((async () => {

                        this.delayInitiated = false;
                        this.nextRequest();

                    }), 1000);

                }

            }

        });
    }

}

module.exports = RequestHandler;</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Client","link":"<a href=\"Client.html\">Client</a>"},{"title":"Client#deleteWebhook","link":"<a href=\"Client.html#deleteWebhook\">Client &rtrif; deleteWebhook</a>"},{"title":"Client#editMessage","link":"<a href=\"Client.html#editMessage\">Client &rtrif; editMessage</a>"},{"title":"Client#error","link":"<a href=\"Client.html#error\">Client &rtrif; error</a>"},{"title":"Client#fetchChannelMessages","link":"<a href=\"Client.html#fetchChannelMessages\">Client &rtrif; fetchChannelMessages</a>"},{"title":"Client#fetchChannelWebhooks","link":"<a href=\"Client.html#fetchChannelWebhooks\">Client &rtrif; fetchChannelWebhooks</a>"},{"title":"Client#followStatusChannel","link":"<a href=\"Client.html#followStatusChannel\">Client &rtrif; followStatusChannel</a>"},{"title":"Client#login","link":"<a href=\"Client.html#login\">Client &rtrif; login</a>"},{"title":"Client#postWebhook","link":"<a href=\"Client.html#postWebhook\">Client &rtrif; postWebhook</a>"},{"title":"Client#purgeChannelMessages","link":"<a href=\"Client.html#purgeChannelMessages\">Client &rtrif; purgeChannelMessages</a>"},{"title":"Client#sendMessage","link":"<a href=\"Client.html#sendMessage\">Client &rtrif; sendMessage</a>"},{"title":"Client#setStatus","link":"<a href=\"Client.html#setStatus\">Client &rtrif; setStatus</a>"},{"title":"Message","link":"<a href=\"Message.html\">Message</a>"},{"title":"Message#edit","link":"<a href=\"Message.html#edit\">Message &rtrif; edit</a>"},{"title":"Message#reply","link":"<a href=\"Message.html#reply\">Message &rtrif; reply</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    

    


  </body>

</html>